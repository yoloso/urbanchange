from io import BytesIO
import math
import os
from PIL import Image
import requests


# Geocoding street segments
def compute_heading(bearing):
    """
    Computes a tuple of headings to be used in the 'heading' parameter of the
    Google Street View API such that the images for a given street segment
    face its buildings at a 90 degree angle.
    :param bearing: The street segment's orientation
    :return: (tuple)
    """
    if 90 >= bearing >= 0:
        return [bearing + 90, bearing + 270]
    elif bearing <= 270:
        return [bearing + 90, bearing - 90]
    elif bearing <= 360:
        return [bearing - 90, bearing - 270]
    else:
        raise Exception('[ERROR] Bearing should be between 0 and 360.')


def generate_new_latlng_from_distance(cur_lat,
                                      cur_lng,
                                      segment_bearing,
                                      distance, radius):
    """

    :param radius: (float) radius of the Earth
    :param distance: (float) Distance in km between the two coordinates
    :param segment_bearing: (float) Bearing in degrees
    :param cur_lat: (float) Starting latitude in degrees
    :param cur_lng: (float) Starting longitude in degrees
    :return: (tuple of float) Ending latitude, longitude coordinates at a
    selected distance and bearing from the starting coordinates
    """
    # Convert to radians
    cur_lat, cur_lng = math.radians(cur_lat), math.radians(cur_lng)
    bearing_rad = math.radians(segment_bearing)

    # Compute new coordinates
    new_lat = math.sin(cur_lat) * math.cos(distance / radius) + \
              math.cos(cur_lat) * math.sin(distance / radius) * math.cos(bearing_rad)
    new_lat = math.asin(new_lat)

    new_lng = math.atan2(
        math.sin(bearing_rad) * math.sin(distance / radius) * math.cos(cur_lat),
        math.cos(distance / radius) - math.sin(cur_lat) * math.sin(new_lat))
    new_lng = cur_lng + new_lng

    # Convert back to degrees and append to coordinate list
    new_lat, new_lng = math.degrees(new_lat), math.degrees(new_lng)

    return new_lat, new_lng


# Generating GSV images
def save_SV_image(params, output_dir, file_name):
    """
    Saves the Google Street View image for a particular location as specified
    by the params dictionary to the chosen output directory.
    :param params: (dict)
    :param output_dir: (str)
    :param file_name: (str)
    :return: Null (saves image to file)
    """
    # Request and get image
    img_base_url = 'https://maps.googleapis.com/maps/api/streetview?'
    img_request = requests.get(img_base_url, params)
    img = Image.open(BytesIO(img_request.content))

    # Save image
    output_file = os.path.join(output_dir, '{}.png'.format(file_name))
    img.save(output_file)


def reverse_geocode(params):
    """
    Generate a list of addresses for a given (lat, lon) coordinate pair.
    :param params: (dict) a dictionary including the API key and latlng
    coordinates for which to generate the addresses
    :return: (dict) a dictionary including the information generated by
    the request to the Geocode API for the location.
    """
    geo_base_url = 'https://maps.googleapis.com/maps/api/geocode/json?'
    return requests.get(geo_base_url, params).json()


# Processing images and annotations
def get_image_name(image_path):
    image_name = image_path.split(os.path.sep)[-1]
    image_name = '.'.join(image_name.split('.')[:-1])
    return image_name


def load_annotations(annotation_path):
    with open(annotation_path, 'r') as file:
        box_list = file.readlines()
    return box_list


def preprocess_box_list(box_list):
    num_objects = len(box_list)
    boxes = []

    for box in box_list:
        pass
    # TODO
    return num_objects, labels, XXX
